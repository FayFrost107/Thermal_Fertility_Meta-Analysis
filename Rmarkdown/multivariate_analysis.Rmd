---
title: "Multivariate Meta-Analysis for Longevity and Reproduction"
author: "Daniel Noble & Fay Frost"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r, packages,echo = FALSE}
#install.packages("pacman")
#devtools::install_github("daniel1noble/metaAidR", force=TRUE)
pacman::p_load(tidyverse, here, metafor, ape, phytools, corrplot, metaAidR)
# source functions
  source(here("R", "func.R"))
```

```{r, load data, echo = FALSE}
## Load in the finalised data
  data <- read.csv(here("data", "cleaned_unique_combo.csv"))

## Doesn't look like data has a cenetred treattemp
  data <- data %>% mutate(c_treattemp = treattemp - 25)

```

```{r, check data, echo = FALSE, include=FALSE}

#  Let's just orient the data length wise as we need it in this format first.
  
  data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
  
  # Not quite where we need it, so lets filter out v and then cbind together
  data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
   data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
  
  # All information should now be ordered correctly and the data frames the same dimensions. We can check
  dim(data_long_es)
  dim(data_long_v)
  
# Now, bind these together
  data_long_final <- cbind(data_long_es, v = data_long_v$es)
  
# Create unique ID for clustered effects
  data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
  
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
  check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)

# OUTCOME: All looks good.
  
# The Experiment code identifiers that are relevant are:
  unique(check$trial) # 0

# We need tp add a shared control column. This is a column that identified, WITHIN a study, what reftemp is used the same for the same "reproduction" and "longevity" effect size
  data_long_final <- data_long_final %>% 
                      group_by(Experiment.code)  %>% 
                      mutate(ref_same = if_else(outcome == "es_reproduction" & unique(reftemp) %in% reftemp, 1, 
                                              if_else(outcome == "es_longevity" & unique(reftemp) %in% reftemp, 2, 0)),
                              shared_control = interaction(Experiment.code, ref_same))  %>% 
                      data.frame()

# Lets have a look. On a quick check this should be the right way around because ref temp is the same for each outcome within a study
         data_long_final  %>% select(Experiment.code, reftemp, treattemp, outcome, shared_control, trial)  %>%  head(., 30)          
```

```{r, v}

# VCV matrix. Let's set up the multivariate meta-analysis model. We first need to create the VCV sampling matrix. This is a block diagonal matrix with the sampling variance for each effect size on the diagonal and the sampling covariance between the two effect sizes on the off-diagonal. We don't know the correlation, but we can assume 0.5. 
 
# V <- metafor::vcalc(vi=v, cluster = trial, subgroup = Experiment.code, type = outcome, data = data_long_final, rho = 0.5, nearpd = TRUE)

# First, lets capture the outcome covariance  
   V_1 <- make_VCV_matrix(data = data_long_final, cluster = "trial",  V = "v", rho = 0.5)

# Using this matrix, we can now capture the shared control. here, we now just feed in the V matrix we just created and the shared control column. This will then create a new V matrix with the shared control column as the cluster.Note that, as we make this matrix more complex the chance of it being PD goes up...so we need to check this.
   V <- metaAidR::make_VCV_matrix(data = data_long_final, matrix = V_1, cluster = "shared_control",  V = "v", rho = 0.5)

# Export V matrix for checking
  write.csv(V, here("Output", "tables", "V.csv"))

# Check that this is set up correctly. Note that there are warnings about non-positive definite matrix. The matrix should be automatically. 
  #V[1:15, 1:15]

  #corrplot(cov2cor(V)) # Takes a while so no need to run all the time

# Check of PD
  corpcor::is.positive.definite(V) # FALSE

# Can bend it to make it PD
  V <- Matrix::nearPD(V)$mat

# Check of PD
  corpcor::is.positive.definite(V) # TRUE
```

```{r, multivariatemodel, eval = FALSE, echo = FALSE}

 # Multivariate model. Using the VCV matrix we can set up the model. We'll keep it simple for now

mv_mlma <- rma.mv(es ~ outcome - 1, V = V, 
               random = list(~outcome - 1 | trial,
                             ~outcome - 1 | Species.latin), 
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")


## Lets try a model with the random effects structure from the univariate case. Not the full structure is: "random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs), R= list(Species.phylo = phylo_matrix)". We also don't know if these models can take a phylogenetic R matrix. So, lets have a look

# Phylogeny. Use reproduction because it should match with longevity in terms of species
   
 tree1 <- read.nexus(here("phylogeny", "all_reproduction_excHUM251_tree.nex"))    
 tree_grafen = compute.brlen(tree1, method="Grafen", power=1)

classes <- read.csv(here("Data", "Species_classifications.CSV")) ## read in species classifications from map

data_long_final$Species.latin[which(data_long_final$Species.latin == "Marasmia exigua")]                <- "Cnaphalocrocis exigua"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Matsumuratettix hieroglyphicus")] <- "Matsumuratettix hiroglyphicus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Mythimna roseilinea")]            <- "Mythimna albipuncta"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Apis craccivora")]                <- "Aphis craccivora"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Cryptoleamus montrouzieri")]      <- "Cryptolaemus montrouzieri"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Asplanchna brightwelli")]         <- "Asplanchna brightwellii"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Brennandania lambi")]             <- "Pygmephorus lambi"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Amblyseius alstoniae")]           <- "Euseius alstoniae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Siphoninus phyllyreae")]          <- "Siphoninus phillyreae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Proprioseiopsis asetus")]         <- "Amblyseius asetus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Parabemisia myrica")]             <- "Parabemisia myricae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Cirrospilus sp. near lyncus")]    <- "Cirrospilus lyncus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Anagyrus sp. nov. nr. sinope" )]  <- "Anagyrus sinope"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Monochamus leuconotus")]          <- "Anthores leuconotus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Ropalosiphum maidis")]            <- "Rhopalosiphum maidis"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Artemia fransiscana")]            <- "Artemia franciscana"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Blathyplectes curculionis")]      <- "Bathyplectes curculionis"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Menochilus sexmaculatus")]        <- "Cheilomenes sexmaculata"
data_long_final$Species.latin[which(data_long_final$Species.latin == "unknown (Tominic)")]              <- "Trichogramma" 

### specify classifications from map
data_long_final$Class <- classes$class[match(data_long_final$Species.latin, classes$species_latin)]
       
 ############################################## End of Fay's amendments #####################################################      
       
# Now we need to prune this tree to the species in this long data
       tree_checks <- tree_checks(data_long_final, tree1, dataCol = "Species.latin", type = "check") # Looks good so we can prune tree

# Prune tree
        tree2 <- tree_checks(data_long_final, tree1, dataCol = "Species.latin", type = "prune") 

# Now, use Fay's code to create R matrix. Not yet working because we need to sort out the species in the data before we can prune
   tree_grafen <- compute.brlen(tree2, method="Grafen", power=1)
 phylo_matrix <- vcv(tree_grafen, cor=TRUE, model="Brownian")

# Now fit the model with phylogeny. That seems to work just fine!
mv_mlma2 <- rma.mv(es ~ outcome - 1, V = V, 
               random = list(~outcome - 1 | trial,
                             ~outcome - 1 | Species.latin), 
               R= list(Species.latin = phylo_matrix),
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")

```

```{r, multivariatemodelsfinal, echo = FALSE}
## Univariate models were found to only need two random effects, obs and study. This greatly simplifies the multivarite model, which can only have two levels anyway. We will save these models because they take quite some time to estimate given how much data is available
rerun = FALSE
if(rerun){
  mv_mlma_1 <- rma.mv(es ~ outcome - 1, V = V, 
                random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                              ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
                struc = "UN", data = data_long_final, test = "t", dfs = "contain")  # struc = "UN" means we estimate the correlation between the two outcomes for each study and obs level random effect. Could also give it c("UN", "UN") to estimate the correlation for each outcome separately but this should take it as UN for both anyway.
  saveRDS(mv_mlma_1, here("output", "models", "mv_mlma_1.rds"))
} else {
  mv_mlma_1 <- readRDS(here("output", "models", "mv_mlma_1.rds"))
}

mv_mlma_1
# Now that we have the MLMA model we can start to estimate different fixed effects and ask if these fixed effects that impact ES for longevity and reproduction differ between the two. 
if(rerun){
mv_mlma_2 <- rma.mv(es ~ outcome*c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")  

saveRDS(mv_mlma_2, here("output", "models", "mv_mlma_2.rds"))
} else {
  mv_mlma_2 <- readRDS(here("output", "models", "mv_mlma_2.rds"))
}
# Now lets tri supressing the intercept. This should now estimate the linear effect of temp on each outcome
mv_mlma_2
## OUTCOME: This modell tells us that: 1) the overall effects on reproduction vs longevity are significantly different from each other when controlling for treattemp; 2) that the treatment temp effect on longevity is significant and that 3) the treattemp effect on reproduction is signioficantly different than its effect on longevity.

if(rerun){
mv_mlma_3 <- rma.mv(es ~ -1 + outcome + outcome:c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")
saveRDS(mv_mlma_3, here("output", "models", "mv_mlma_3.rds"))
} else {
  mv_mlma_3 <- readRDS(here("output", "models", "mv_mlma_3.rds"))
}
mv_mlma_3
```

```{r, nonlin_multivariatefinal}
# We'll now run the multivariate model with non-linear terms as was done in the univariate cases.
rerun2=FALSE
if(rerun2){
  mv_mlma_4 <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V,    
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")
  saveRDS(mv_mlma_4, here("output", "models", "mv_mlma_4.rds"))
} else {
  mv_mlma_4 <- readRDS(here("output", "models", "mv_mlma_4.rds"))
}
  mv_mlma_4

# We can get confidence intervals by profiling the liklihood
  if(rerun2){
  cis <- confint(mv_mlma_4, rho = 1)
  write.csv(cis, here("output", "tables", "mv_mlma_4_cis.csv"))
  } else {
    cis <- read.csv(here("output", "tables", "mv_mlma_4_cis.csv"))
  }
 cis
```

```{r, correation}

# Lets explore the among study correlation. 
data  %>%  group_by(Experiment.code)  %>% summarise(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) + geom_point() + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") + theme_bw() + geom_text(aes(label = Experiment.code), size = 3, nudge_x = 0.8, nudge_y = 0.8)

```


```{r, eval=FALSE, pest_sub_analysis}
pest <- subset(data_long_final, Agricultural.importance == "Pest")


 V_2 <- make_VCV_matrix(data = pest, cluster = "trial",  V = "v", rho = 0.5)

 V2 <- metaAidR::make_VCV_matrix(data = pest, matrix = V_2, cluster = "shared_control",  V = "v", rho = 0.5)

 # Check of PD
  corpcor::is.positive.definite(V2) # FALSE

# Can bend it to make it PD
  V2 <- Matrix::nearPD(V2)$mat

# Check of PD
  corpcor::is.positive.definite(V2) # TRUE
   
   
 mv_mlma_pest <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V2,    
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = pest, test = "t", dfs = "contain")
 
 saveRDS(mv_mlma_pest, here("output", "models", "mv_mlma_pest.rds"))

```
