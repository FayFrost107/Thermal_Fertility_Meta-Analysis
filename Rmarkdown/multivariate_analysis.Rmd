---
title: "Multivariate Meta-Analysis for Longevity and Reproduction"
author: "Daniel Noble & Fay Frost"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r, packages,echo = FALSE}
install.packages("pacman")
pacman::p_load(tidyverse, here, metafor, ape, phytools)

# source functions
  source(here("R", "func.R"))
```

```{r, load data, echo = FALSE}
## Load in the finalised data
  data <- read.csv(here("data", "cleaned_unique_combo.csv"))
```

```{r, check data, echo = FALSE, include=FALSE}

#  Let's just orient the data length wise as we need it in this format first.
  
  data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
  
  # Not quite where we need it, so lets filter out v and then cbind together
  data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
   data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
  
  # All information should now be ordered correctly and the data frames the same dimensions. We can check
  dim(data_long_es)
  dim(data_long_v)
  
# Now, bind these together
  data_long_final <- cbind(data_long_es, v = data_long_v$es)
  
# Create unique ID for clustered effects
  data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
  
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
  check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)

# OUTCOME: There still appear to be columns(~40) with more than 1 effect size for each longevity/reproduction effect size. This is also not because we could have males and female effect sizes as including sex does not resolve this problem
  
# The Experiment code identifiers that are relevant are:
  unique(check$trial)
  
```

```{r, multivariatemodel}

# VCV matrix. Let's set up the multivariate meta-analysis model. We first need to create the VCV sampling matrix. This is a block diagonal matrix with the sampling variance for each effect size on the diagonal and the sampling covariance between the two effect sizes on the off-diagonal. We don't know the correlation, but we can assume 0.5. 
  
  V <- metafor::vcalc(vi=v, cluster = trial, type = outcome, data = data_long_final, rho = 0.5, nearpd = TRUE)

# Check that this is set up correctly. Note that there are warnings about non-positive definite matrix. The matrix should be automatically. 
  V[1:6, 1:6]

# Multivariate model. Using the VCV matrix we can set up the model. We'll keep it simple for now

mv_mlma <- rma.mv(es ~ outcome - 1, V = V, 
               random = list(~outcome - 1 | trial,
                             ~outcome - 1 | Species.latin), 
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")


## Lets try a model with the random effects structure from the univariate case. Not the full structure is: "random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs), R= list(Species.phylo = phylo_matrix)". We also don't know if these models can take a phylogenetic R matrix. So, lets have a look

# Phylogeny. Use reproduction because it should match with longevity in terms of species
   
       

######################################### Fay added new code to update species names and prune tree  ##################################     

# This code needs to be right at the start of our R script, ** before any analysis **  
# as the correct species names and classifications come form this code !!!

 tree1 <- read.nexus(here("phylogeny", "all_reproduction_excHUM251_tree.nex"))    
 tree_grafen = compute.brlen(tree1, method="Grafen", power=1)

classes <- read.csv(here("Data", "Species_classifications.CSV")) ## read in species classifications from map

data_long_final$Species.latin[which(data_long_final$Species.latin == "Marasmia exigua")]                <- "Cnaphalocrocis exigua"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Matsumuratettix hieroglyphicus")] <- "Matsumuratettix hiroglyphicus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Mythimna roseilinea")]            <- "Mythimna albipuncta"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Apis craccivora")]                <- "Aphis craccivora"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Cryptoleamus montrouzieri")]      <- "Cryptolaemus montrouzieri"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Asplanchna brightwelli")]         <- "Asplanchna brightwellii"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Brennandania lambi")]             <- "Pygmephorus lambi"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Amblyseius alstoniae")]           <- "Euseius alstoniae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Siphoninus phyllyreae")]          <- "Siphoninus phillyreae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Proprioseiopsis asetus")]         <- "Amblyseius asetus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Parabemisia myrica")]             <- "Parabemisia myricae"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Cirrospilus sp. near lyncus")]    <- "Cirrospilus lyncus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Anagyrus sp. nov. nr. sinope" )]  <- "Anagyrus sinope"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Monochamus leuconotus")]          <- "Anthores leuconotus"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Ropalosiphum maidis")]            <- "Rhopalosiphum maidis"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Artemia fransiscana")]            <- "Artemia franciscana"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Blathyplectes curculionis")]      <- "Bathyplectes curculionis"
data_long_final$Species.latin[which(data_long_final$Species.latin == "Menochilus sexmaculatus")]        <- "Cheilomenes sexmaculata"
data_long_final$Species.latin[which(data_long_final$Species.latin == "unknown (Tominic)")]              <- "Trichogramma" 


### specify classifications from map
data_long_final$Class <- classes$class[match(data_long_final$Species.latin, classes$species_latin)]


## decide which species are in or out
notin <- setdiff(tree1$tip.label, data_long_final$Species.latin)
indata <- setdiff(tree1$tip.label, notin)

## prune tree
prune_tree <- drop.tip(tree_grafen, notin)
phylo_matrix <- vcv(prune_tree, cor=TRUE, model="Brownian")

## number of indata should equal # of unique data_long_final species. 
setdiff(unique(data_long_final$Species.latin), indata)
      
       
       
 ############################################## End of Fay's amendments #####################################################      
       


# Now we need to prune this tree to the species in this long data
       tree_checks <- tree_checks(data_long_final, tree1, dataCol = "Species.latin", type = "check")

# Now, use Fay's code to create R matrix. Not yet working because we need to sort out the species in the data before we can prune
   #tree_grafen <- compute.brlen(tree1, method="Grafen", power=1)
 # phylo_matrix <- vcv(tree_grafen, cor=TRUE, model="Brownian")

data_long_final$Species.phylo <- factor(data_long_final$Species.latin)   # Species names for phylo matrix
data_long_final$species <- factor(data_long_final$Species.latin)  


mv_mlma2 <- rma.mv(es ~ outcome - 1, V = V, 
               random = list(~outcome - 1 | trial,
                             ~outcome - 1 | Species.phylo), 
               R= list(Species.phylo = phylo_matrix),
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")

```

