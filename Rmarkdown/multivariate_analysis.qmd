---
title: "Multivariate Meta-Analysis for Longevity and Reproduction"
author: "Daniel Noble & Fay Frost"
format: docx
execute:
  freeze: auto  # re-render only when source changes
  cache: false
  echo: false
  warning: false
  error: false
  include: true
crossref:
  fig-title: 'Figure'
  fig-labels: arabic
  title-delim: "-"
  fig-prefix: "Figure"
  tbl-prefix: "Table"
---

```{r, packages}
#| echo: false
#| warning: false
#| include: false
#install.packages("pacman")
#devtools::install_github("daniel1noble/metaAidR", force=TRUE)
pacman::p_load(tidyverse, here, metafor, ape, phytools, corrplot, metaAidR, orchaRd, latex2exp, flextable)
# source functions
  source(here("R", "func.R"))

  options(digits = 2)
```

```{r, load data}
#| echo: false
#| warning: false
#| include: false
## Load in the finalised data
  data <- read.csv(here("data", "cleaned_unique_combo.csv"))

## Doesn't look like data has a cenetred treattemp
  data <- data %>% mutate(c_treattemp = treattemp - 25)

```

```{r, check data}
#| echo: false
#| warning: false
#| include: false
#  Let's just orient the data length wise as we need it in this format first.
  
  data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
  
  # Not quite where we need it, so lets filter out v and then cbind together
  data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
   data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
  
  # All information should now be ordered correctly and the data frames the same dimensions. We can check
  dim(data_long_es)
  dim(data_long_v)
  
# Now, bind these together
  data_long_final <- cbind(data_long_es, v = data_long_v$es)
  
# Create unique ID for clustered effects
  data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
  
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
  check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)

# OUTCOME: All looks good.
  
# The Experiment code identifiers that are relevant are:
  unique(check$trial) # 0

# We need tp add a shared control column. This is a column that identified, WITHIN a study, what reftemp is used the same for the same "reproduction" and "longevity" effect size
  data_long_final <- data_long_final %>% 
                      group_by(Experiment.code)  %>% 
                      mutate(ref_same = if_else(outcome == "es_reproduction" & unique(reftemp) %in% reftemp, 1, 
                                              if_else(outcome == "es_longevity" & unique(reftemp) %in% reftemp, 2, 0)),
                              shared_control = interaction(Experiment.code, ref_same))  %>% 
                      data.frame()

# Lets have a look. On a quick check this should be the right way around because ref temp is the same for each outcome within a study
         data_long_final  %>% select(Experiment.code, reftemp, treattemp, outcome, shared_control, trial)  %>%  head(., 30)          
```

```{r, v}
#| echo: false
#| warning: false
#| include: false
# VCV matrix. Let's set up the multivariate meta-analysis model. We first need to create the VCV sampling matrix. This is a block diagonal matrix with the sampling variance for each effect size on the diagonal and the sampling covariance between the two effect sizes on the off-diagonal. We don't know the correlation, but we can assume 0.5. 
 
# V <- metafor::vcalc(vi=v, cluster = trial, subgroup = Experiment.code, type = outcome, data = data_long_final, rho = 0.5, nearpd = TRUE)

# First, lets capture the outcome covariance  
   V_1 <- make_VCV_matrix(data = data_long_final, cluster = "trial",  V = "v", rho = 0.5)

# Using this matrix, we can now capture the shared control. here, we now just feed in the V matrix we just created and the shared control column. This will then create a new V matrix with the shared control column as the cluster.Note that, as we make this matrix more complex the chance of it being PD goes up...so we need to check this.
   V <- metaAidR::make_VCV_matrix(data = data_long_final, matrix = V_1, cluster = "shared_control",  V = "v", rho = 0.5)

# Export V matrix for checking
  write.csv(V, here("Output", "tables", "V.csv"))

# Check that this is set up correctly. Note that there are warnings about non-positive definite matrix. The matrix should be automatically. 
  #V[1:15, 1:15]

  #corrplot(cov2cor(V)) # Takes a while so no need to run all the time

# Check of PD
  corpcor::is.positive.definite(V) # FALSE

# Can bend it to make it PD
  V <- Matrix::nearPD(V)$mat

# Check of PD
  corpcor::is.positive.definite(V) # TRUE
```

```{r, multivariatemodelsfinal}
#| echo: false
#| warning: false
#| include: false
## Univariate models were found to only need two random effects, obs and study. This greatly simplifies the multivarite model, which can only have two levels anyway. We will save these models because they take quite some time to estimate given how much data is available
rerun = FALSE
if(rerun){
  mv_mlma_1 <- rma.mv(es ~ outcome - 1, V = V, 
                random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                              ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
                struc = "UN", data = data_long_final, test = "t", dfs = "contain")  # struc = "UN" means we estimate the correlation between the two outcomes for each study and obs level random effect. Could also give it c("UN", "UN") to estimate the correlation for each outcome separately but this should take it as UN for both anyway.
  saveRDS(mv_mlma_1, here("output", "models", "mv_mlma_1.rds"))
} else {
  mv_mlma_1 <- readRDS(here("output", "models", "mv_mlma_1.rds"))
}

mv_mlma_1
# Now that we have the MLMA model we can start to estimate different fixed effects and ask if these fixed effects that impact ES for longevity and reproduction differ between the two. 
if(rerun){
mv_mlma_2 <- rma.mv(es ~ outcome*c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")  

saveRDS(mv_mlma_2, here("output", "models", "mv_mlma_2.rds"))
} else {
  mv_mlma_2 <- readRDS(here("output", "models", "mv_mlma_2.rds"))
}
# Now lets tri supressing the intercept. This should now estimate the linear effect of temp on each outcome
mv_mlma_2
## OUTCOME: This modell tells us that: 1) the overall effects on reproduction vs longevity are significantly different from each other when controlling for treattemp; 2) that the treatment temp effect on longevity is significant and that 3) the treattemp effect on reproduction is signioficantly different than its effect on longevity.

if(rerun){
mv_mlma_3 <- rma.mv(es ~ -1 + outcome + outcome:c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")
saveRDS(mv_mlma_3, here("output", "models", "mv_mlma_3.rds"))
} else {
  mv_mlma_3 <- readRDS(here("output", "models", "mv_mlma_3.rds"))
}
mv_mlma_3
```

```{r, nonlin_multivariatefinal}
#| echo: false
#| warning: false
#| include: false
# We'll now run the multivariate model with non-linear terms as was done in the univariate cases.
rerun2=FALSE
if(rerun2){
  mv_mlma_4 <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V,    
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_long_final, test = "t", dfs = "contain")
  saveRDS(mv_mlma_4, here("output", "models", "mv_mlma_4.rds"))
} else {
  mv_mlma_4 <- readRDS(here("output", "models", "mv_mlma_4.rds"))
}
  mv_mlma_4

# We can get confidence intervals by profiling the liklihood
  if(rerun2){
  cis_phi <- confint(mv_mlma_3, phi = 1)
  cis_rho <- confint(mv_mlma_3, rho = 1)
  write.csv(cis, here("output", "tables", "mv_mlma_4_cis.csv"))
  } else {
    cis <- read.csv(here("output", "tables", "mv_mlma_4_cis.csv"))
  }
 cis

mv_pi <- mod_results(mv_mlma_3, mod = "outcome", group = "Paper.code")
```

```{r, eval=FALSE, pest_sub_analysis}
pest <- subset(data_long_final, Agricultural.importance == "Pest")

 V_2 <- make_VCV_matrix(data = pest, cluster = "trial",  V = "v", rho = 0.5)

 V2 <- metaAidR::make_VCV_matrix(data = pest, matrix = V_2, cluster = "shared_control",  V = "v", rho = 0.5)

 # Check of PD
  corpcor::is.positive.definite(V2) # FALSE

# Can bend it to make it PD
  V2 <- Matrix::nearPD(V2)$mat

# Check of PD
  corpcor::is.positive.definite(V2) # TRUE
   
 mv_mlma_pest <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V2,    
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = pest, test = "t", dfs = "contain")
 
 saveRDS(mv_mlma_pest, here("output", "models", "mv_mlma_pest.rds"))

```

# Multivariate meta-analysis and meta-regression

Reproductive traits were more strongly impacted by temperature changes than longevity when controlling for temperature (contrast = `r mv_mlma_2$b[2]`, 95% CI: `r mv_mlma_2$ci.lb[2]` to `r mv_mlma_2$ci.ub[2]`, df = `r mv_mlma_2$ddf[2]`, *p*-value = `r p_value(mv_mlma_2$pval[2])`). At 25$^o$C, longevity was reduced by `r mv_mlma_3$b[1]` SD units relative to the control (95% CI: `r mv_mlma_3$ci.lb[1]` to `r mv_mlma_3$ci.ub[1]`, df = `r mv_mlma_3$ddf[1]`, *p*-value = `r p_value(mv_mlma_3$pval[1])`). In contrast, reproduction was significantly reduced by `r mv_mlma_3$b[2]` SD units relative to the control (95% CI: `r mv_mlma_3$ci.lb[2]` to `r mv_mlma_3$ci.ub[2]`, df = `r mv_mlma_3$ddf[2]`, *p*-value = `r p_value(mv_mlma_3$pval[2])`). However, there was high heterogeneity in both traits with prediction intervals spanning `r min(mv_pi$mod_table$lowerPR)` to `r max(mv_pi$mod_table$upperPR)` (@fig-fig1). 

Mean effects changed in complicated ways with changes in temperaure, with significant non-linear patterns that depended on the effect outcome (@tbl-tbl1), with effect magnitude and direction changing non-linearly with temperature increases (FAY, MAYBE ADD FIG). Interestingly, studies that observed larger changes in reprodcution also observed correlated changes in longevity (between study correlation = `r mv_mlma_3$phi`), however, at the within study-level there was a much weaker correlation (within-study correlation = `r mv_mlma_3$rho`, @fig-fig2). 

```{r, fig-fig1}
#| label: fig-fig1
#| fig-cap: Orchard plot with the overall meta-analytic mean (central dots) for reproduction and longevity traits. Thick bars are the 95 confidence intervals and thin bars are the 95 prediction intervals. Data are weighted by their precision (inverse sampling error). Plot is truncated for ease of visualisation. k is the number of effect sizes and n the number of studies. Given we limited our analysis to studies with both reproduction and longevity the samples sizes are the same for both trait types.

samples <- mv_pi$data  %>% group_by(moderator)  %>% summarise(n = length(unique(stdy)), k = n())

p <- orchard_plot(mv_mlma_3, mod = "outcome", group = "Paper.code", xlab = "SMD", angle = 45) + ylim(-6.5, 6.5) +
      annotate("text", x = 1.5, y = 3, label = paste0("k = ", samples$k[1], " (", samples$n[1], ")"), size = 5) + 
      annotate("text", x = 1.5, y = -3, label = TeX("Mean at 25$^o$C"), size = 5) + scale_x_discrete(labels=c("Es_reproduction"  ="Reproduction", "Es_longevity" = "Longevity")) + theme(axis.text = element_text(size = 12), axis.title = element_text(size = 18), legend.text = element_text(size = 12), legend.title = element_text(size = 14))
ggsave(p, filename = "Output/Figures/fig_orchard.png", width = 6.617284, height = 5.851852)
```


```{r, tbl-tbl1}
#| label: tbl-tbl1
#| tbl-cap: Non-linear effects of temperature on mean effect size for longevity and reproduction
table <- data.frame(Parameters = c("Longevity (mean)", "Reproduction (mean)", "Linear Treatment Temperature (centered) - Longevity", "Linear Treatment Temperature (centered) - Reproduction", "Quadratic Treatment Temperature (centered) - Longevity", "Quadratic Treatment Temperature (centered) - Reproduction", "Cubic Treatment Temperature (centered) - Longevity", "Cubic Treatment Temperature (centered) - Reproduction"),
                    Est. = round(mv_mlma_4$b, 4),
                    `L 95% CI` = round(mv_mlma_4$ci.lb, 4),
                    `U 95% CI` = round(mv_mlma_4$ci.ub, 4),
                    `df` = round(mv_mlma_4$ddf,2),
                    `p-value` = sapply(round(mv_mlma_4$pval,4), function(x) p_value(x)), row.names = NULL, check.names = FALSE)
flextable(table)
```


```{r, fig-fig2}
#| label: fig-fig2
#| fig-cap: Between study correlation for reproduction and longevity
# Lets explore the among study correlation. 
data  %>%  group_by(Experiment.code)  %>% summarise(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) + 
                    geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
                    theme_bw() +
                    coord_cartesian(xlim=c(-60,20)) +
                    geom_text(aes(label = Experiment.code), size = 3, nudge_x = 0.8, nudge_y = 0.8)

```
```{r, fig-fig3}
#| label: fig-fig3
#| fig-cap: Zoomed Between study correlation for reproduction and longevity
# Lets explore the among study correlation. 
data  %>%  group_by(Experiment.code)  %>% summarise(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) + 
                    geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
                    theme_bw() +
                    coord_cartesian(xlim=c(-5,5), ylim = c(-5,5)) 
```

# Sensitivity Analysis 
This removes the smallest and largest 5% effect sizes (so 10% of the data in total). The plot above shows only the experiments that have outlying effect sizes not the specific effect size itself.


```{r, sa_multivariate}
#| echo: false
#| warning: false
#| include: false
# We'll now run the multivariate model with non-linear terms as was done in the univariate cases.
rerun3=FALSE
if(rerun3){
  

minq <- quantile(data_long_final$es, 0.05)
maxq <- quantile(data_long_final$es, 0.95)

sdata <- subset(data_long_final, es > minq & es < maxq)

## make V matrix for sensitivity data
 V_2 <- make_VCV_matrix(data = sdata, cluster = "trial",  V = "v", rho = 0.5)

 V2 <- metaAidR::make_VCV_matrix(data = sdata, matrix = V_2, cluster = "shared_control",  V = "v", rho = 0.5)

 # Check of PD
  corpcor::is.positive.definite(V2) # FALSE

# Can bend it to make it PD
  V2 <- Matrix::nearPD(V2)$mat

# Check of PD
  corpcor::is.positive.definite(V2) # TRUE
  
  mlma_sa <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V2,    
               random = list(~outcome - 1 | trial,   ~outcome - 1 | Paper.code),  
               struc = "UN", data = sdata, test = "t", dfs = "contain")
  
  saveRDS(mlma_sa, here("output", "models", "mlma_sa.rds"))
  saveRDS(sdata, here("output", "Output data", "mlma_sa_data.rds"))
} else {
  mlma_sa <- readRDS(here("output", "models", "mlma_sa.rds"))
  sdata <- readRDS(here("output", "Output data", "mlma_sa_data.rds"))
}
```

When removing the 5% largest and smallest effect sizes, the following effect sizes are removed.

```{r}
#| echo: false
#| warning: false
#| include: true
#| eval: true

sort(setdiff(data_long_final$trial, sdata$trial))

```


```{r, splittingwamrcool}


if(rerun){
  data_warm <- subset(data_long_final, warm.cool == "Warm")
  data_cool <- subset(data_long_final, warm.cool == "Cool")
  
  
  ## make V matrix for warm
 V_warm <- make_VCV_matrix(data = data_warm, cluster = "trial",  V = "v", rho = 0.5)
 V2_warm <- metaAidR::make_VCV_matrix(data = data_warm, matrix = V_warm, cluster = "shared_control",  V = "v", rho = 0.5)
  corpcor::is.positive.definite(V2_warm) # FALSE
  V2_warm <- Matrix::nearPD(V2_warm)$mat
  corpcor::is.positive.definite(V2_warm) # TRUE
  
  
  ## make V matrix for cool
 V_cool <- make_VCV_matrix(data = data_cool, cluster = "trial",  V = "v", rho = 0.5)
 V2_cool <- metaAidR::make_VCV_matrix(data = data_cool, matrix = V_cool, cluster = "shared_control",  V = "v", rho = 0.5)
 corpcor::is.positive.definite(V2_cool) # FALSE
 V2_cool <- Matrix::nearPD(V2_cool)$mat
 corpcor::is.positive.definite(V2_cool) # TRUE
  
mv_mlma_split.warm <- rma.mv(es ~ outcome*c_treattemp, V = V_warm,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
               random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
                             ~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
               struc = "UN", data = data_warm, test = "t", dfs = "contain")
saveRDS(mv_mlma_split.warm, here("output", "models", "mv_mlma_split.warm.rds"))

mv_mlma_split.cool <- rma.mv(es ~ outcome*c_treattemp, V = V_cool,   
               random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code), 
               struc = "UN", data = data_cool, test = "t", dfs = "contain")
saveRDS(mv_mlma_split.cool, here("output", "models", "mv_mlma_split.cool.rds"))


} else {
  mv_mlma_split.warm <- readRDS(here("output", "models", "mv_mlma_split.warm.rds"))
  mv_mlma_split.cool <- readRDS(here("output", "models", "mv_mlma_split.cool.rds"))
}
```










