} else {
g <- (mean/sd)*((4*(n^(3/2)))/(1+4*n))
}
return(g)
}
################ I  can combine this into the paiwise calc so I can easily remove specific es.
ref_temp <- warmdata$ref_temp
ref_mean <- warmdata$ref_mean
ref_sd <- warmdata$ref_sd
ref_ani <- warmdata$ref_ani
ref_N <- warmdata$ref_N
calculate_smd <- function(rtemp1, rmean1, rsd1, rani1, rn1, temp2, mean2, sd2, ani2, n2){
if (is.na(temp2)) {
smd <- NA  # Initialize as NA (numeric)
smd_v <- NA
gtest <- NA
} else if (rtemp1 != temp2) {
smd <- escalc(measure = "SMD", m2i=rmean1, sd2i=rsd1, n2i=rn1, m1i=mean2, sd1i=sd2, n1i=n2)[1]
smd_v <- escalc(measure = "SMD", m2i=rmean1, sd2i=rsd1, n2i=rani1, m1i=mean2, sd1i=sd2, n1i=ani2)[2]
} else {
smd <- 0
smd_v <- 0 # rtemp1 equals temp2, so smd is set to 0
}
Smd <- cbind(smd, smd_v, temp2-rtemp1, rtemp1, temp2, calculate_g(temp2, mean2, sd2, n2))
return(Smd)
}
esdata <- c()
for(i in 1:nrow(warmdata)){
row <- calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[1]]$Temp1[i], column_sets[[1]]$Mean1[i], column_sets[[1]]$SD1[i], column_sets[[1]]$ani_1[i], column_sets[[1]]$N1[i])
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[2]]$Temp2[i], column_sets[[2]]$Mean2[i], column_sets[[2]]$SD2[i], column_sets[[2]]$ani_2[i], column_sets[[2]]$N2[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[3]]$Temp3[i], column_sets[[3]]$Mean3[i], column_sets[[3]]$SD3[i], column_sets[[3]]$ani_3[i], column_sets[[3]]$N3[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[4]]$Temp4[i], column_sets[[4]]$Mean4[i], column_sets[[4]]$SD4[i], column_sets[[4]]$ani_4[i], column_sets[[4]]$N4[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[5]]$Temp5[i], column_sets[[5]]$Mean5[i], column_sets[[5]]$SD5[i], column_sets[[5]]$ani_5[i], column_sets[[5]]$N5[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[6]]$Temp6[i], column_sets[[6]]$Mean6[i], column_sets[[6]]$SD6[i], column_sets[[6]]$ani_6[i], column_sets[[6]]$N6[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[7]]$Temp7[i], column_sets[[7]]$Mean7[i], column_sets[[7]]$SD7[i], column_sets[[7]]$ani_7[i], column_sets[[7]]$N7[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[8]]$Temp8[i], column_sets[[8]]$Mean8[i], column_sets[[8]]$SD8[i], column_sets[[8]]$ani_8[i], column_sets[[8]]$N8[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[9]]$Temp9[i], column_sets[[9]]$Mean9[i], column_sets[[9]]$SD9[i], column_sets[[9]]$ani_9[i], column_sets[[9]]$N9[i]))
colnames(row) <- c("es.1", "v.1", "diff", "reftemp", "treattemp", "gtest",
"es.2", "v.2", "diff", "reftemp", "treattemp", "gtest",
"es.3", "v.3", "diff", "reftemp", "treattemp", "gtest",
"es.4", "v.4", "diff", "reftemp", "treattemp", "gtest",
"es.5", "v.5", "diff", "reftemp", "treattemp", "gtest",
"es.6", "v.6", "diff", "reftemp", "treattemp", "gtest",
"es.7", "v.7", "diff", "reftemp", "treattemp", "gtest",
"es.8", "v.8", "diff", "reftemp", "treattemp", "gtest",
"es.9", "v.9", "diff", "reftemp", "treattemp", "gtest")
esdata <- rbind(esdata, row)
}
pairwise.test <- esdata
studydat <- warmdata[,1:34]
colnames(pairwise.test) <- c("es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest")
test.1 <- cbind(studydat, pairwise.test[,1:6])
test.2 <- cbind(studydat, pairwise.test[,7:12])
test.3 <- cbind(studydat, pairwise.test[,13:18])
test.4 <- cbind(studydat, pairwise.test[,19:24])
test.5 <- cbind(studydat, pairwise.test[,25:30])
test.6 <- cbind(studydat, pairwise.test[,31:36])
test.7 <- cbind(studydat, pairwise.test[,37:42])
test.8 <- cbind(studydat, pairwise.test[,43:48])
test.9 <- cbind(studydat, pairwise.test[,49:54])
total.test <- rbind(test.1, test.2, test.3, test.4, test.5, test.6, test.7, test.8, test.9)
cleaned_df <- total.test[!is.na(total.test$es),]
cleaned_df$warm.cool <- NA
cleaned_df$warm.cool[which(cleaned_df$diff < 0)] <- "Cool"
cleaned_df$warm.cool[which(cleaned_df$diff == 0)] <- "Reference"
cleaned_df$warm.cool[which(cleaned_df$diff > 0)] <- "Warm"
##  Count how many values in total are < 3 i.e. how many effect sizes we'd end up removing
table(cleaned_df$gtest < 3) #= 256
subg <- subset(cleaned_df, gtest < 3) ## need to remove all these effect sizes and all effectsizes from studies with controls/references with a gtest > 3
View(subg)
View(cleaned_df)
cleaned_df$es[which(cleaned_df$gtest == "inf")]
cleaned_df$es[which(cleaned_df$gtest == inf)]
cleaned_df$es[which(cleaned_df$gtest = inf)]
cleaned_df$es[which(cleaned_df$gtest = NaN)]
cleaned_df$es[which(cleaned_df$gtest == NaN)]
cleaned_df$es[which(cleaned_df$gtest == "NaN")]
0/0
1/0
cleaned_df$es[which(cleaned_df$gtest == "IaN")]
cleaned_df$es[which(cleaned_df$gtest == "Inf")]
sort(cleaned_df$es[which(cleaned_df$gtest == "NaN")])
sort(cleaned_df$es[which(cleaned_df$gtest < 3)])
sort(cleaned_df$es[which(cleaned_df$gtest == "Inf")])
load("~/GitHub/Thermal_Fertility_Meta-Analysis/Output/reproduction_meta_analysis_output.RData")
summary(meta7)
summary(meta3)
i2_ml(meta3, method=c("ratio")) # Heterogeneity at each random factor level
library(metafor)
library(ggplot2)
library(ape)
library(rotl)
library(multcomp)
library(dplyr)
library(tidyr)
summary(meta2)
i2_ml(meta2, method=c("ratio")) # Heterogeneity at each random factor level
# To install the orchaRd package:
#install.packages("pacman")
#pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, emmeans)
#devtools::install_github("daniel1noble/orchaRd", force = TRUE)
library(orchaRd)
library(ggtree)
library(clubSandwich)
library(rmarkdown)
summary(meta3)
i2_ml(meta3, method=c("ratio")) # Heterogeneity at each random factor level
summary(meta5)
i2_ml(meta5, method=c("ratio"))
summary(meta4)
i2_ml(meta4, method=c("ratio"))
load("~/GitHub/Thermal_Fertility_Meta-Analysis/Output/longevity_meta_analysis_output.RData")
summary(meta3)
i2_ml(meta3, method=c("ratio"))
summary(meta4)
i2_ml(meta4, method=c("ratio"))
rm(list=ls()) # Clear R environment
library(metafor)
library(ggplot2)
library(ape)
library(rotl)
library(multcomp)
library(dplyr)
# To install the orchaRd package:
#install.packages("pacman")
#pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, emmeans)
#devtools::install_github("daniel1noble/orchaRd", force = TRUE)
library(orchaRd)
##########################################################################################################
#--------------#
# 1. Setup     #
#--------------#
### Read in effect size data
effectdata <- read.csv("Data/Survival project all pairwise.es.csv")
survdata_warm <- subset(effectdata, Trait.category == "Survival" & warm.cool == "Warm" )
survdata_cool <- subset(effectdata, Trait.category == "Survival" & warm.cool == "Cool" )
allsurv <- rbind(survdata_warm, survdata_cool)
### select data for analysis
rdata <- allsurv
rdata <- subset(rdata, Paper.code != "HUM251")
rdata <- subset(rdata, Paper.code != "OSM205")
### Species names which need changing for phylogeny.
rdata$Species.latin[which(rdata$Species.latin == "Cosmocomoidea ashmeadi")]              <- "Gonatocerus ashmeadi"
rdata$Species.latin[which(rdata$Species.latin == "Cosmocomoidea triguttata")]   <- "Gonatocerus triguttatus"
rdata$Species.latin[which(rdata$Species.latin == "Mythimna roseilinea")]            <-  "Mythimna albipuncta"
rdata$Species.latin[which(rdata$Species.latin == "Daphnia australis")]            <-  "Daphniopsis australis"
### Create random factors into data frame
rdata$obs <- factor(c(1:nrow(rdata)))                # Unique observation code
rdata$study_code <- factor(rdata$Paper.code)         # Model requires column names study_code (this is biggest level of nested code structure)
rdata$Species.phylo <- factor(rdata$Species.latin)   # Species names for phylo matrix
rdata$species <- factor(rdata$Species.latin)         # Another species column for ranom factor
precision <- sqrt(1/rdata$v)                         # inverse standard error
rdata[,"precision"] <- precision
str(rdata)
nlevels(rdata$species)    # Check number of species
nlevels(rdata$study_code) # Check number of studies
#### Import Tree #############
tree1 <- read.nexus("Phylogeny/all_surv_excHUM251_tree.nex")
tree_grafen = compute.brlen(tree1, method="Grafen", power=1)
tree <- ape::multi2di(tree_grafen, random = TRUE)
phylo_matrix <- vcv(tree_grafen, cor=TRUE, model="Brownian") # Make phylogenetic matrix
# use a randomization approach to deal with polytomies.
# Could this this approach or another detailed here: https://search.r-project.org/CRAN/refmans/RRphylo/html/fix.poly.html
########################################    Models   #### ######################################################
#--------------------------#
# 2. Random Effects Models #
#--------------------------#
# Simple model (no random effects)
meta1 <- rma.uni(es, v, data= rdata, method= "REML")
summary(meta1)
# Adding four random factors
meta2 <- rma.mv(es, v, random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs),
R= list(Species.phylo = phylo_matrix), data= rdata, method= "REML")
summary(meta2)
i2_ml(meta2, method=c("ratio")) # Heterogeneity at each random factor level
# Accounting for non-independence of data points from the same experiment
# Assumes a correlation of 0.5 between effect sizes from the same experiment
rdata$shared_control <- factor(rdata$Effect.size.code)
VCV_shared <- matrix(0, nrow = dim(rdata)[1], ncol = dim(rdata)[1])
rownames(VCV_shared) <- rdata[, "es"]
colnames(VCV_shared) <- rdata[, "es"]
shared_coord <- which(rdata[, "shared_control"] %in% rdata[duplicated(rdata[, "shared_control"]), "shared_control"] == TRUE)
#new_vcv <- impute_covariance_matrix(vi=rdata$v, cluster = rdata$study_code, r=0.5)
# Finds effect sizes that share a control group
combinations <- do.call("rbind", tapply(shared_coord, rdata[shared_coord,  "shared_control"], function(x) t(utils::combn(x, 2))))
for (i in 1:dim(combinations)[1]) {
p1 <- combinations[i, 1]
p2 <- combinations[i, 2]
p1_p2_cov <- 0.5 * sqrt(rdata[p1, "v"]) * sqrt(rdata[p2, "v"])
VCV_shared[p1, p2] <- p1_p2_cov
VCV_shared[p2, p1] <- p1_p2_cov
} # Calculates the covariance between effect sizes and enters them in each combination of coordinates
diag(VCV_shared) <- rdata[, "v"] # Enters recalculated effect size sampling variances into diagonals
# Add new variance matrix into the mixed-effects meta-analysis model
meta3 <- rma.mv(es, VCV_shared, random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~ 1|shared_control, ~1|obs),
R= list(Species.phylo = phylo_matrix), data= rdata, method= "REML")
summary(meta3)
i2_ml(meta3, method=c("ratio")) # Heterogeneity at each random factor level
summary(meta8)
i2_ml(meta8, method=c("ratio")) # Heterogeneity at each random factor level
## without phylogeny, species or shared_control
meta8 <- rma.mv(es, VCV_shared, random= list(~ 1|study_code, ~1|obs), data= rdata, method= "REML")
summary(meta8)
i2_ml(meta8, method=c("ratio")) # Heterogeneity at each random factor level
##### meta6
# Add new variance matrix into the mixed-effects meta-analysis model
meta3 <- rma.mv(es, VCV_shared, random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs),
R= list(Species.phylo = phylo_matrix), data= rdata, method= "REML")
summary(meta3)
i2_ml(meta3, method=c("ratio")) # Heterogeneity at each random factor level
###-----------------------------------------------------###
### Multilevel meta-analysis using Metafor              ###
### Author: Fay Frost [fay.frost@liverpool.ac.uk]             ###
### Code adapted from Liam Dougherty.
### University of Liverpool                             ###
### Date: August 2023                                   ###
###-----------------------------------------------------###
############################################ Preamble ######################################################
rm(list=ls()) # Clear R environment
library(metafor)
library(ggplot2)
library(ape)
library(rotl)
library(multcomp)
library(dplyr)
# To install the orchaRd package:
#install.packages("pacman")
#pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, emmeans)
#devtools::install_github("daniel1noble/orchaRd", force = TRUE)
library(orchaRd)
##########################################################################################################
#--------------#
# 1. Setup     #
#--------------#
### Read in effect size data
effectdata <- read.csv("Data/Survival project all pairwise.es.csv")
survdata_warm <- subset(effectdata, Trait.category == "Survival" & warm.cool == "Warm" )
survdata_cool <- subset(effectdata, Trait.category == "Survival" & warm.cool == "Cool" )
allsurv <- rbind(survdata_warm, survdata_cool)
### select data for analysis
rdata <- allsurv
rdata <- subset(rdata, Paper.code != "HUM251")
rdata <- subset(rdata, Paper.code != "OSM205")
### Species names which need changing for phylogeny.
rdata$Species.latin[which(rdata$Species.latin == "Cosmocomoidea ashmeadi")]              <- "Gonatocerus ashmeadi"
rdata$Species.latin[which(rdata$Species.latin == "Cosmocomoidea triguttata")]   <- "Gonatocerus triguttatus"
rdata$Species.latin[which(rdata$Species.latin == "Mythimna roseilinea")]            <-  "Mythimna albipuncta"
rdata$Species.latin[which(rdata$Species.latin == "Daphnia australis")]            <-  "Daphniopsis australis"
### Create random factors into data frame
rdata$obs <- factor(c(1:nrow(rdata)))                # Unique observation code
rdata$study_code <- factor(rdata$Paper.code)         # Model requires column names study_code (this is biggest level of nested code structure)
rdata$Species.phylo <- factor(rdata$Species.latin)   # Species names for phylo matrix
rdata$species <- factor(rdata$Species.latin)         # Another species column for ranom factor
precision <- sqrt(1/rdata$v)                         # inverse standard error
rdata[,"precision"] <- precision
str(rdata)
nlevels(rdata$species)    # Check number of species
nlevels(rdata$study_code) # Check number of studies
#### Import Tree #############
tree1 <- read.nexus("Phylogeny/all_surv_excHUM251_tree.nex")
tree_grafen = compute.brlen(tree1, method="Grafen", power=1)
tree <- ape::multi2di(tree_grafen, random = TRUE)
phylo_matrix <- vcv(tree_grafen, cor=TRUE, model="Brownian") # Make phylogenetic matrix
# use a randomization approach to deal with polytomies.
# Could this this approach or another detailed here: https://search.r-project.org/CRAN/refmans/RRphylo/html/fix.poly.html
########################################    Models   #### ######################################################
#--------------------------#
# 2. Random Effects Models #
#--------------------------#
# Simple model (no random effects)
meta1 <- rma.uni(es, v, data= rdata, method= "REML")
summary(meta1)
# Adding four random factors
meta2 <- rma.mv(es, v, random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs),
R= list(Species.phylo = phylo_matrix), data= rdata, method= "REML")
summary(meta2)
i2_ml(meta2, method=c("ratio")) # Heterogeneity at each random factor level
# Accounting for non-independence of data points from the same experiment
# Assumes a correlation of 0.5 between effect sizes from the same experiment
rdata$shared_control <- factor(rdata$Effect.size.code)
VCV_shared <- matrix(0, nrow = dim(rdata)[1], ncol = dim(rdata)[1])
rownames(VCV_shared) <- rdata[, "es"]
colnames(VCV_shared) <- rdata[, "es"]
shared_coord <- which(rdata[, "shared_control"] %in% rdata[duplicated(rdata[, "shared_control"]), "shared_control"] == TRUE)
#new_vcv <- impute_covariance_matrix(vi=rdata$v, cluster = rdata$study_code, r=0.5)
# Finds effect sizes that share a control group
combinations <- do.call("rbind", tapply(shared_coord, rdata[shared_coord,  "shared_control"], function(x) t(utils::combn(x, 2))))
for (i in 1:dim(combinations)[1]) {
p1 <- combinations[i, 1]
p2 <- combinations[i, 2]
p1_p2_cov <- 0.5 * sqrt(rdata[p1, "v"]) * sqrt(rdata[p2, "v"])
VCV_shared[p1, p2] <- p1_p2_cov
VCV_shared[p2, p1] <- p1_p2_cov
} # Calculates the covariance between effect sizes and enters them in each combination of coordinates
diag(VCV_shared) <- rdata[, "v"] # Enters recalculated effect size sampling variances into diagonals
# Add new variance matrix into the mixed-effects meta-analysis model
meta3 <- rma.mv(es, VCV_shared, random= list(~ 1|Species.phylo, ~ 1|species, ~ 1|study_code, ~1|obs),
R= list(Species.phylo = phylo_matrix), data= rdata, method= "REML")
summary(meta3)
i2_ml(meta3, method=c("ratio")) # Heterogeneity at each random factor level
load("~/GitHub/Thermal_Fertility_Meta-Analysis/Output/reproduction_meta_analysis_output.RData")
meta_treat_sex <- rma.mv(es, VCV_shared_sex,  mod= ~poly(c_treattemp, degree=2, raw=TRUE)*Sex.exposed-1,
random= list(~ 1|study_code,  ~1|obs), data= new_data, method= "REML")
summary(meta_treat_sex)
summary(meta_treat_sex)
mv_mlma_4 <- readRDS(here("output", "models", "mv_mlma_pest.rds"))
summary(mv_mlma_4)
### Multivariate models
mv_mlma_4 <- readRDS(here("output", "models", "mv_mlma_4.rds"))
summary(mv_mlma_4)
View(mv_mlma_4)
#install.packages("pacman")
#devtools::install_github("daniel1noble/metaAidR", force=TRUE)
pacman::p_load(tidyverse, here, metafor, ape, phytools, corrplot, metaAidR)
# source functions
source(here("R", "func.R"))
## Load in the finalised data
data <- read.csv(here("data", "cleaned_unique_combo.csv"))
## Doesn't look like data has a cenetred treattemp
data <- data %>% mutate(c_treattemp = treattemp - 25)
#  Let's just orient the data length wise as we need it in this format first.
data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
# Not quite where we need it, so lets filter out v and then cbind together
data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
# All information should now be ordered correctly and the data frames the same dimensions. We can check
dim(data_long_es)
dim(data_long_v)
# Now, bind these together
data_long_final <- cbind(data_long_es, v = data_long_v$es)
# Create unique ID for clustered effects
data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)
# OUTCOME: All looks good.
# The Experiment code identifiers that are relevant are:
unique(check$trial) # 0
# We need tp add a shared control column. This is a column that identified, WITHIN a study, what reftemp is used the same for the same "reproduction" and "longevity" effect size
data_long_final <- data_long_final %>%
group_by(Experiment.code)  %>%
mutate(ref_same = if_else(outcome == "es_reproduction" & unique(reftemp) %in% reftemp, 1,
if_else(outcome == "es_longevity" & unique(reftemp) %in% reftemp, 2, 0)),
shared_control = interaction(Experiment.code, ref_same))  %>%
data.frame()
# Lets have a look. On a quick check this should be the right way around because ref temp is the same for each outcome within a study
data_long_final  %>% select(Experiment.code, reftemp, treattemp, outcome, shared_control, trial)  %>%  head(., 30)
#install.packages("pacman")
#devtools::install_github("daniel1noble/metaAidR", force=TRUE)
pacman::p_load(tidyverse, here, metafor, ape, phytools, corrplot, metaAidR)
# source functions
source(here("R", "func.R"))
#  Let's just orient the data length wise as we need it in this format first.
data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
# Not quite where we need it, so lets filter out v and then cbind together
data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
# All information should now be ordered correctly and the data frames the same dimensions. We can check
dim(data_long_es)
dim(data_long_v)
# Now, bind these together
data_long_final <- cbind(data_long_es, v = data_long_v$es)
# Create unique ID for clustered effects
data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)
# OUTCOME: All looks good.
# The Experiment code identifiers that are relevant are:
unique(check$trial) # 0
# We need tp add a shared control column. This is a column that identified, WITHIN a study, what reftemp is used the same for the same "reproduction" and "longevity" effect size
data_long_final <- data_long_final %>%
group_by(Experiment.code)  %>%
mutate(ref_same = if_else(outcome == "es_reproduction" & unique(reftemp) %in% reftemp, 1,
if_else(outcome == "es_longevity" & unique(reftemp) %in% reftemp, 2, 0)),
shared_control = interaction(Experiment.code, ref_same))  %>%
data.frame()
# Lets have a look. On a quick check this should be the right way around because ref temp is the same for each outcome within a study
data_long_final  %>% select(Experiment.code, reftemp, treattemp, outcome, shared_control, trial)  %>%  head(., 30)
# VCV matrix. Let's set up the multivariate meta-analysis model. We first need to create the VCV sampling matrix. This is a block diagonal matrix with the sampling variance for each effect size on the diagonal and the sampling covariance between the two effect sizes on the off-diagonal. We don't know the correlation, but we can assume 0.5.
# V <- metafor::vcalc(vi=v, cluster = trial, subgroup = Experiment.code, type = outcome, data = data_long_final, rho = 0.5, nearpd = TRUE)
# First, lets capture the outcome covariance
V_1 <- make_VCV_matrix(data = data_long_final, cluster = "trial",  V = "v", rho = 0.5)
# Using this matrix, we can now capture the shared control. here, we now just feed in the V matrix we just created and the shared control column. This will then create a new V matrix with the shared control column as the cluster.Note that, as we make this matrix more complex the chance of it being PD goes up...so we need to check this.
V <- metaAidR::make_VCV_matrix(data = data_long_final, matrix = V_1, cluster = "shared_control",  V = "v", rho = 0.5)
# Export V matrix for checking
write.csv(V, here("Output", "tables", "V.csv"))
# Check that this is set up correctly. Note that there are warnings about non-positive definite matrix. The matrix should be automatically.
#V[1:15, 1:15]
#corrplot(cov2cor(V)) # Takes a while so no need to run all the time
# Check of PD
corpcor::is.positive.definite(V) # FALSE
# Can bend it to make it PD
V <- Matrix::nearPD(V)$mat
# Check of PD
corpcor::is.positive.definite(V) # TRUE
pest <- subset(data_long_final, Agricultural.importance == "Pest")
View(pest)
nlevels(as.factor(pest$Paper.code))
nlevels(as.factor(pest$Experiment.code))
## Geary's test (mean* sqrt(n) )/ SD
warmdata <- read.csv("EDA/Survival project effect size reftemp FF warm.csv")
# Create a list of column names for each treatment
column_sets <- list(warmdata[c("Temp1", "Mean1", "SD1", "N1", "ani_1")],
warmdata[c("Temp2", "Mean2", "SD2", "N2", "ani_2")],
warmdata[c("Temp3", "Mean3", "SD3", "N3", "ani_3")],
warmdata[c("Temp4", "Mean4", "SD4", "N4", "ani_4")],
warmdata[c("Temp5", "Mean5", "SD5", "N5", "ani_5")],
warmdata[c("Temp6", "Mean6", "SD6", "N6", "ani_6")],
warmdata[c("Temp7", "Mean7", "SD7", "N7", "ani_7")],
warmdata[c("Temp8", "Mean8", "SD8", "N8", "ani_8")],
warmdata[c("Temp9", "Mean9", "SD9", "N9", "ani_9")])
#Gearys <- NA
calculate_g <- function(temp, mean, sd, n){
if (is.na(temp)){
g <- NA  # Initialize as NA (numeric)
} else {
g <- (mean/sd)*((4*(n^(3/2)))/(1+4*n))
}
return(g)
}
################ I  can combine this into the paiwise calc so I can easily remove specific es.
ref_temp <- warmdata$ref_temp
ref_mean <- warmdata$ref_mean
ref_sd <- warmdata$ref_sd
ref_ani <- warmdata$ref_ani
ref_N <- warmdata$ref_N
calculate_smd <- function(rtemp1, rmean1, rsd1, rani1, rn1, temp2, mean2, sd2, ani2, n2){
if (is.na(temp2)) {
smd <- NA  # Initialize as NA (numeric)
smd_v <- NA
gtest <- NA
} else if (rtemp1 != temp2) {
smd <- escalc(measure = "SMD", m2i=rmean1, sd2i=rsd1, n2i=rn1, m1i=mean2, sd1i=sd2, n1i=n2)[1]
smd_v <- escalc(measure = "SMD", m2i=rmean1, sd2i=rsd1, n2i=rani1, m1i=mean2, sd1i=sd2, n1i=ani2)[2]
} else {
smd <- 0
smd_v <- 0 # rtemp1 equals temp2, so smd is set to 0
}
Smd <- cbind(smd, smd_v, temp2-rtemp1, rtemp1, temp2, calculate_g(temp2, mean2, sd2, n2))
return(Smd)
}
esdata <- c()
for(i in 1:nrow(warmdata)){
row <- calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[1]]$Temp1[i], column_sets[[1]]$Mean1[i], column_sets[[1]]$SD1[i], column_sets[[1]]$ani_1[i], column_sets[[1]]$N1[i])
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[2]]$Temp2[i], column_sets[[2]]$Mean2[i], column_sets[[2]]$SD2[i], column_sets[[2]]$ani_2[i], column_sets[[2]]$N2[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[3]]$Temp3[i], column_sets[[3]]$Mean3[i], column_sets[[3]]$SD3[i], column_sets[[3]]$ani_3[i], column_sets[[3]]$N3[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[4]]$Temp4[i], column_sets[[4]]$Mean4[i], column_sets[[4]]$SD4[i], column_sets[[4]]$ani_4[i], column_sets[[4]]$N4[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[5]]$Temp5[i], column_sets[[5]]$Mean5[i], column_sets[[5]]$SD5[i], column_sets[[5]]$ani_5[i], column_sets[[5]]$N5[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[6]]$Temp6[i], column_sets[[6]]$Mean6[i], column_sets[[6]]$SD6[i], column_sets[[6]]$ani_6[i], column_sets[[6]]$N6[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[7]]$Temp7[i], column_sets[[7]]$Mean7[i], column_sets[[7]]$SD7[i], column_sets[[7]]$ani_7[i], column_sets[[7]]$N7[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[8]]$Temp8[i], column_sets[[8]]$Mean8[i], column_sets[[8]]$SD8[i], column_sets[[8]]$ani_8[i], column_sets[[8]]$N8[i]))
row <- cbind(row, calculate_smd(ref_temp[i], ref_mean[i], ref_sd[i], ref_ani[i], ref_N[i], column_sets[[9]]$Temp9[i], column_sets[[9]]$Mean9[i], column_sets[[9]]$SD9[i], column_sets[[9]]$ani_9[i], column_sets[[9]]$N9[i]))
colnames(row) <- c("es.1", "v.1", "diff", "reftemp", "treattemp", "gtest",
"es.2", "v.2", "diff", "reftemp", "treattemp", "gtest",
"es.3", "v.3", "diff", "reftemp", "treattemp", "gtest",
"es.4", "v.4", "diff", "reftemp", "treattemp", "gtest",
"es.5", "v.5", "diff", "reftemp", "treattemp", "gtest",
"es.6", "v.6", "diff", "reftemp", "treattemp", "gtest",
"es.7", "v.7", "diff", "reftemp", "treattemp", "gtest",
"es.8", "v.8", "diff", "reftemp", "treattemp", "gtest",
"es.9", "v.9", "diff", "reftemp", "treattemp", "gtest")
esdata <- rbind(esdata, row)
}
pairwise.test <- esdata
studydat <- warmdata[,1:34]
colnames(pairwise.test) <- c("es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest",
"es", "v", "diff", "reftemp", "treattemp", "gtest")
test.1 <- cbind(studydat, pairwise.test[,1:6])
test.2 <- cbind(studydat, pairwise.test[,7:12])
test.3 <- cbind(studydat, pairwise.test[,13:18])
test.4 <- cbind(studydat, pairwise.test[,19:24])
test.5 <- cbind(studydat, pairwise.test[,25:30])
test.6 <- cbind(studydat, pairwise.test[,31:36])
test.7 <- cbind(studydat, pairwise.test[,37:42])
test.8 <- cbind(studydat, pairwise.test[,43:48])
test.9 <- cbind(studydat, pairwise.test[,49:54])
total.test <- rbind(test.1, test.2, test.3, test.4, test.5, test.6, test.7, test.8, test.9)
cleaned_df <- total.test[!is.na(total.test$es),]
cleaned_df$warm.cool <- NA
cleaned_df$warm.cool[which(cleaned_df$diff < 0)] <- "Cool"
cleaned_df$warm.cool[which(cleaned_df$diff == 0)] <- "Reference"
cleaned_df$warm.cool[which(cleaned_df$diff > 0)] <- "Warm"
##  Count how many values in total are < 3 i.e. how many effect sizes we'd end up removing
table(cleaned_df$gtest < 3) #= 256
subg <- subset(cleaned_df, gtest < 3) ## need to remove all these effect sizes and all effectsizes from studies with controls/references with a gtest > 3
which(cleaned_df$gtest == "Inf")
cleaned_df[which(cleaned_df$gtest == "Inf")]
cleaned_df[which(cleaned_df$gtest == "Inf"),]
inf.data <- cleaned_df[which(cleaned_df$gtest == "Inf"),]
nan.data <- cleaned_df[which(cleaned_df$gtest == "NaN"),]
write.csv(inf.data, "EDA/Geartstest/inf_data.csv")
write.csv(inf.data, "EDA/Gearystest/inf_data.csv")
write.csv(NaN.data, "EDA/Gearystest/NaN_data.csv")
write.csv(nan.data, "EDA/Gearystest/NaN_data.csv")
write.csv(cleaned_df, "EDA/Gearystest/all_gearys_data.csv")
View(inf.data)
View(nan.data)
View(cleaned_df)
