geom_line(aes(y = preds.4, color = "4", linetype= "4"), size = 1.5) +
geom_line(aes(y = preds.5, color = "5", linetype= "5"), size = 1.5) +
geom_line(aes(y = preds.6, color = "6", linetype= "6"), size = 1.5) +
labs(title = "Predicted effect size curves for longevity using different polynomials",
x = "Temperature deviation from 25C",
y = "Effect size") +
theme_minimal() +
coord_cartesian(ylim = c(-10, 10)) +
scale_color_manual(values = c("2" = cbp2[2], "3" = cbp2[3], "4" = cbp2[4], "5" = cbp2[5], "6" = cbp2[8]),
name = "Polynomial Degree") +
scale_linetype_manual(values = c("solid", "dashed", "dotted", "dotdash", "longdash" ), name = "Polynomial Degree")
#| echo: false
#| warning: false
#| include: false
#install.packages("pacman")
#devtools::install_github("daniel1noble/metaAidR", force=TRUE)
pacman::p_load(tidyverse, here, metafor, ape, phytools, corrplot, metaAidR, orchaRd, latex2exp, flextable)
# source functions
source(here("R", "func.R"))
options(digits = 2)
#| echo: false
#| warning: false
#| include: false
## Load in the finalised data
data <- read.csv(here("data", "cleaned_unique_combo.csv"))
## Doesn't look like data has a centered treattemp
data <- data %>% mutate(c_treattemp = treattemp - 25)
#| echo: false
#| warning: false
#| include: false
#  Let's just orient the data length wise as we need it in this format first.
data_long <- data %>% pivot_longer(cols = c(es_reproduction, es_longevity, v_reproduction, v_longevity), names_to = "outcome", values_to = "es") %>% data.frame()
# Not quite where we need it, so lets filter out v and then cbind together
data_long_es <- data_long %>% filter(outcome %in% c("es_reproduction", "es_longevity"))
data_long_v <- data_long %>% filter(outcome %in% c("v_reproduction", "v_longevity"))
# All information should now be ordered correctly and the data frames the same dimensions. We can check
dim(data_long_es)
dim(data_long_v)
# Now, bind these together
data_long_final <- cbind(data_long_es, v = data_long_v$es)
# Create unique ID for clustered effects
data_long_final$trial <- with(data_long_final, interaction(Experiment.code, diff))
# Now, let's check that this data is set up correctly. If we group by Experiment.code, diff and outcome then we should have a maximum of 1 effect size for each study/diff in each outcome category
check <- data_long_final %>% group_by(trial, outcome) %>% summarise(n=n()) %>% filter(n !=1)
# OUTCOME: All looks good.
# The Experiment code identifiers that are relevant are:
unique(check$trial) # 0
# We need tp add a shared control column. This is a column that identified, WITHIN a study, what reftemp is used the same for the same "reproduction" and "longevity" effect size
data_long_final <- data_long_final %>%
group_by(Experiment.code)  %>%
mutate(ref_same = if_else(outcome == "es_reproduction" & unique(reftemp) %in% reftemp, 1,
if_else(outcome == "es_longevity" & unique(reftemp) %in% reftemp, 2, 0)),
shared_control = interaction(Experiment.code, ref_same))  %>%
data.frame()
# Lets have a look. On a quick check this should be the right way around because ref temp is the same for each outcome within a study
data_long_final  %>% select(Experiment.code, reftemp, treattemp, outcome, shared_control, trial)  %>%  head(., 30)
#| echo: false
#| warning: false
#| include: false
# VCV matrix. Let's set up the multivariate meta-analysis model. We first need to create the VCV sampling matrix. This is a block diagonal matrix with the sampling variance for each effect size on the diagonal and the sampling covariance between the two effect sizes on the off-diagonal. We don't know the correlation, but we can assume 0.5.
# V <- metafor::vcalc(vi=v, cluster = trial, subgroup = Experiment.code, type = outcome, data = data_long_final, rho = 0.5, nearpd = TRUE)
# First, lets capture the outcome covariance
V_1 <- make_VCV_matrix(data = data_long_final, cluster = "trial",  V = "v", rho = 0.5)
# Using this matrix, we can now capture the shared control. here, we now just feed in the V matrix we just created and the shared control column. This will then create a new V matrix with the shared control column as the cluster.Note that, as we make this matrix more complex the chance of it being PD goes up...so we need to check this.
V <- metaAidR::make_VCV_matrix(data = data_long_final, matrix = V_1, cluster = "shared_control",  V = "v", rho = 0.5)
# Export V matrix for checking
write.csv(V, here("Output", "tables", "V.csv"))
# Check that this is set up correctly. Note that there are warnings about non-positive definite matrix. The matrix should be automatically.
#V[1:15, 1:15]
#corrplot(cov2cor(V)) # Takes a while so no need to run all the time
# Check of PD
corpcor::is.positive.definite(V) # FALSE
# Can bend it to make it PD
V <- Matrix::nearPD(V)$mat
# Check of PD
corpcor::is.positive.definite(V) # TRUE
#| echo: false
#| warning: false
#| include: false
## Univariate models were found to only need two random effects, obs and study. This greatly simplifies the multivariate model, which can only have two levels anyway. We will save these models because they take quite some time to estimate given how much data is available
rerun = FALSE
if(rerun){
mv_mlma_1 <- rma.mv(es ~ outcome - 1, V = V,
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_long_final, test = "t", dfs = "contain")  # struc = "UN" means we estimate the correlation between the two outcomes for each study and obs level random effect. Could also give it c("UN", "UN") to estimate the correlation for each outcome separately but this should take it as UN for both anyway.
saveRDS(mv_mlma_1, here("output", "models", "mv_mlma_1.rds"))
} else {
mv_mlma_1 <- readRDS(here("output", "models", "mv_mlma_1.rds"))
}
mv_mlma_1
# Now that we have the MLMA model we can start to estimate different fixed effects and ask if these fixed effects that impact ES for longevity and reproduction differ between the two.
if(rerun){
mv_mlma_2 <- rma.mv(es ~ outcome*c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_long_final, test = "t", dfs = "contain")
saveRDS(mv_mlma_2, here("output", "models", "mv_mlma_2.rds"))
} else {
mv_mlma_2 <- readRDS(here("output", "models", "mv_mlma_2.rds"))
}
# Now lets try suppressing the intercept. This should now estimate the linear effect of temp on each outcome
mv_mlma_2
## OUTCOME: This model tells us that: 1) the overall effects on reproduction vs longevity are significantly different from each other when controlling for treattemp; 2) that the treatment temp effect on longevity is significant and that 3) the treattemp effect on reproduction is significantly different than its effect on longevity.
if(rerun){
mv_mlma_3 <- rma.mv(es ~ -1 + outcome + outcome:c_treattemp, V = V,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_long_final, test = "t", dfs = "contain")
saveRDS(mv_mlma_3, here("output", "models", "mv_mlma_3.rds"))
} else {
mv_mlma_3 <- readRDS(here("output", "models", "mv_mlma_3.rds"))
}
mv_mlma_3
#| echo: false
#| warning: false
#| include: false
# We'll now run the multivariate model with non-linear terms as was done in the univariate cases.
rerun2=FALSE
if(rerun2){
mv_mlma_4 <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V,
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_long_final, test = "t", dfs = "contain")
saveRDS(mv_mlma_4, here("output", "models", "mv_mlma_4.rds"))
} else {
mv_mlma_4 <- readRDS(here("output", "models", "mv_mlma_4.rds"))
}
mv_mlma_4
# We can get confidence intervals by profiling the likelihood
if(rerun2){
cis_phi <- confint(mv_mlma_3, phi = 1)
cis_rho <- confint(mv_mlma_3, rho = 1)
write.csv(cis, here("output", "tables", "mv_mlma_4_cis.csv"))
} else {
cis <- read.csv(here("output", "tables", "mv_mlma_4_cis.csv"))
}
cis
mv_pi <- mod_results(mv_mlma_3, mod = "outcome", group = "Paper.code")
#| label: fig-fig1
#| fig-cap: Orchard plot with the overall meta-analytic mean (central dots) for reproduction and longevity traits. Thick bars are the 95 confidence intervals and thin bars are the 95 prediction intervals. Data are weighted by their precision (inverse sampling error). Plot is truncated for ease of visualisation. k is the number of effect sizes and n the number of studies. Given we limited our analysis to studies with both reproduction and longevity the samples sizes are the same for both trait types.
samples <- mv_pi$data  %>% group_by(moderator)  %>% summarise(n = length(unique(stdy)), k = n())
p <- orchard_plot(mv_mlma_3, mod = "outcome", group = "Paper.code", xlab = "SMD", angle = 45) + ylim(-6.5, 6.5) +
annotate("text", x = 1.5, y = 3, label = paste0("k = ", samples$k[1], " (", samples$n[1], ")"), size = 5) +
annotate("text", x = 1.5, y = -3, label = TeX("Mean at 25$^o$C"), size = 5) + scale_x_discrete(labels=c("Es_reproduction"  ="Reproduction", "Es_longevity" = "Longevity")) + theme(axis.text = element_text(size = 12), axis.title = element_text(size = 18), legend.text = element_text(size = 12), legend.title = element_text(size = 14))
ggsave(p, filename = "Output/Figures/fig_orchard.png", width = 6.617284, height = 5.851852)
p
#| label: tbl-tbl1
#| tbl-cap: Non-linear effects of temperature on mean effect size for longevity and reproduction
table <- data.frame(Parameters = c("Longevity (mean)", "Reproduction (mean)", "Linear Treatment Temperature (centered) - Longevity", "Linear Treatment Temperature (centered) - Reproduction", "Quadratic Treatment Temperature (centered) - Longevity", "Quadratic Treatment Temperature (centered) - Reproduction", "Cubic Treatment Temperature (centered) - Longevity", "Cubic Treatment Temperature (centered) - Reproduction"),
Est. = round(mv_mlma_4$b, 4),
`L 95% CI` = round(mv_mlma_4$ci.lb, 4),
`U 95% CI` = round(mv_mlma_4$ci.ub, 4),
`df` = round(mv_mlma_4$ddf,2),
`p-value` = sapply(round(mv_mlma_4$pval,4), function(x) p_value(x)), row.names = NULL, check.names = FALSE)
flextable(table)
#| label: fig-fig2
#| fig-cap: Between study correlation for reproduction and longevity
# Lets explore the among study correlation.
data  %>%  group_by(Experiment.code)  %>% summarise(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) +
geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
theme_bw() +
coord_cartesian(xlim=c(-60,20)) +
geom_text(aes(label = Experiment.code), size = 3, nudge_x = 0.8, nudge_y = 0.8)
#| label: fig-fig3
#| fig-cap: Zoomed Between study correlation for reproduction and longevity
# Lets explore the among study correlation.
data  %>%  group_by(Experiment.code)  %>% summarise(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) +
geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
theme_bw() +
coord_cartesian(xlim=c(-5,5), ylim = c(-5,5))
#| echo: false
#| warning: false
#| include: false
# We'll now run the multivariate model with non-linear terms as was done in the univariate cases.
rerun3=FALSE
if(rerun3){
minq <- quantile(data_long_final$es, 0.05)
maxq <- quantile(data_long_final$es, 0.95)
sdata <- subset(data_long_final, es > minq & es < maxq)
## make V matrix for sensitivity data
V_2 <- make_VCV_matrix(data = sdata, cluster = "trial",  V = "v", rho = 0.5)
V2 <- metaAidR::make_VCV_matrix(data = sdata, matrix = V_2, cluster = "shared_control",  V = "v", rho = 0.5)
# Check of PD
corpcor::is.positive.definite(V2) # FALSE
# Can bend it to make it PD
V2 <- Matrix::nearPD(V2)$mat
# Check of PD
corpcor::is.positive.definite(V2) # TRUE
mlma_sa <- rma.mv(es ~ -1 + outcome + outcome:poly(c_treattemp, degree=3, raw=TRUE), V = V2,
random = list(~outcome - 1 | trial,   ~outcome - 1 | Paper.code),
struc = "UN", data = sdata, test = "t", dfs = "contain")
saveRDS(mlma_sa, here("output", "models", "mlma_sa.rds"))
saveRDS(sdata, here("output", "Output data", "mlma_sa_data.rds"))
} else {
mlma_sa <- readRDS(here("output", "models", "mlma_sa.rds"))
sdata <- readRDS(here("output", "Output data", "mlma_sa_data.rds"))
}
#| echo: false
#| warning: false
#| include: true
#| eval: true
sort(setdiff(data_long_final$trial, sdata$trial))
if(rerun){
data_warm <- subset(data_long_final, warm.cool == "Warm")
data_cool <- subset(data_long_final, warm.cool == "Cool")
## make V matrix for warm
V_warm <- make_VCV_matrix(data = data_warm, cluster = "trial",  V = "v", rho = 0.5)
V2_warm <- metaAidR::make_VCV_matrix(data = data_warm, matrix = V_warm, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_warm) # FALSE
V2_warm <- Matrix::nearPD(V2_warm)$mat
corpcor::is.positive.definite(V2_warm) # TRUE
## make V matrix for cool
V_cool <- make_VCV_matrix(data = data_cool, cluster = "trial",  V = "v", rho = 0.5)
V2_cool <- metaAidR::make_VCV_matrix(data = data_cool, matrix = V_cool, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_cool) # FALSE
V2_cool <- Matrix::nearPD(V2_cool)$mat
corpcor::is.positive.definite(V2_cool) # TRUE
### Linear models
mv_mlma_split.warm <- rma.mv(es ~ outcome*c_treattemp, V = V_warm,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_warm, test = "t", dfs = "contain")
saveRDS(mv_mlma_split.warm, here("output", "models", "mv_mlma_split.warm.rds"))
if(rerun2){
cis_phi_warm <- confint(mv_mlma_split.warm, phi = 1)
cis_rho_warm <- confint(mv_mlma_split.warm, rho = 1)
write.csv(cis_warm, here("output", "tables", "mv_mlma_split.warm_cis.csv"))
} else {
cis_warm <- read.csv(here("output", "tables", "mv_mlma_split.warm_cis.csv"))
}
cis_warm
mv_mlma_split.cool <- rma.mv(es ~ outcome*c_treattemp, V = V_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
saveRDS(mv_mlma_split.cool, here("output", "models", "mv_mlma_split.cool.rds"))
### Quadratic models
mv_mlma_split.warm_quad <- rma.mv(es ~ outcome*poly(c_treattemp, degree=2, raw=TRUE), V = V_warm,
random = list(~outcome - 1 | trial,
~outcome - 1 | Paper.code),
struc = "UN", data = data_warm, test = "t", dfs = "contain")
summary(mv_mlma_split.warm_quad)
saveRDS(mv_mlma_split.warm_quad, here("output", "models", "mv_mlma_split.warm_quad.rds"))
mv_mlma_split.cool_quad <- rma.mv(es ~ outcome*poly(c_treattemp, degree=2, raw=TRUE), V = V_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
summary(mv_mlma_split.cool_quad)
saveRDS(mv_mlma_split.cool_quad, here("output", "models", "mv_mlma_split.cool_quad.rds"))
if(rerun2){
cis_phi_cool <- confint(mv_mlma_split.cool, phi = 1)
cis_rho_cool <- confint(mv_mlma_split.cool, rho = 1)
write.csv(cis_cool, here("output", "tables", "mv_mlma_split.cool_cis.csv"))
} else {
cis_cool <- read.csv(here("output", "tables", "mv_mlma_split.cool_cis.csv"))
}
cis_cool
### Cubic models
mv_mlma_split.warm_cubic <- rma.mv(es ~ outcome*poly(c_treattemp, degree=3, raw=TRUE), V = V_warm,
random = list(~outcome - 1 | trial,
~outcome - 1 | Paper.code),
struc = "UN", data = data_warm, test = "t", dfs = "contain")
summary(mv_mlma_split.warm_cubic)
saveRDS(mv_mlma_split.warm_cubic, here("output", "models", "mv_mlma_split.warm_cubic.rds"))
mv_mlma_split.cool_cubic <- rma.mv(es ~ outcome*poly(c_treattemp, degree=3, raw=TRUE), V = V_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
summary(mv_mlma_split.cool_cubic)
saveRDS(mv_mlma_split.cool_cubic, here("output", "models", "mv_mlma_split.cool_cubic.rds"))
} else {
mv_mlma_split.warm <- readRDS(here("output", "models", "mv_mlma_split.warm.rds"))
mv_mlma_split.cool <- readRDS(here("output", "models", "mv_mlma_split.cool.rds"))
mv_mlma_split.warm_quad <- readRDS(here("output", "models", "mv_mlma_split.warm_quad.rds"))
mv_mlma_split.cool_quad <- readRDS(here("output", "models", "mv_mlma_split.cool_quad.rds"))
mv_mlma_split.warm_cubic <- readRDS(here("output", "models", "mv_mlma_split.warm_cubic.rds"))
mv_mlma_split.cool_cubic <- readRDS(here("output", "models", "mv_mlma_split.cool_cubic.rds"))
}
data_warm2 <- subset(data, warm.cool == "Warm")
data_cool2 <- subset(data, warm.cool == "Cool")
#| fig-cap: Zoomed Between study correlation for reproduction and longevity- warm
data_warm2  %>%  group_by(Experiment.code)  %>% reframe(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) +
geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
theme_bw() +
coord_cartesian(xlim=c(-5,5), ylim = c(-5,5)) +
labs(title = "Between-study correlation- warm")
#| fig-cap: Zoomed Between study correlation for reproduction and longevity- cool
data_cool2  %>%  group_by(Experiment.code)  %>% reframe(es_repro = mean(es_reproduction), es_long = mean(es_longevity), mean_v = (v_reproduction + v_longevity)/2) %>% ggplot(aes(x = es_repro, y = es_long, size = mean_v)) +
geom_point(alpha = 1/10) + labs(x = "SMD (Reproduction)", y = "SMD (Longevity)", size =  "Sampling Variance") +
theme_bw() +
coord_cartesian(xlim=c(-5,5), ylim = c(-5,5))+
labs(title = "Between-study correlation- cool")
data_warm <- subset(data_long_final, warm.cool == "Warm")
data_cool <- subset(data_long_final, warm.cool == "Cool")
# Warm
preds.mlma.warm <- predict(mv_mlma_split.warm, addx=TRUE)
mlma_warm_data <- data_warm
mlma_warm_data$pred <- preds.mlma.warm$pred
mlma_warm_data$pred.lb <- preds.mlma.warm$pi.lb
mlma_warm_data$pred.ub <- preds.mlma.warm$pi.ub
mlma_warm_data$c.lb <- preds.mlma.warm$ci.lb
mlma_warm_data$c.ub <- preds.mlma.warm$ci.ub
ggplot(data = mlma_warm_data, aes(x = c_treattemp, y = pred, col = outcome, linetype = outcome)) +
geom_ribbon(aes(ymin = c.lb, ymax = c.ub, fill = outcome), alpha = 0.15) +
geom_line() +
scale_color_manual(values = c("purple", "orange")) +
scale_fill_manual(values = c("purple", "orange")) +
scale_linetype_manual(values = c("solid", "dashed")) +
theme_bw() +
labs(title = "Predicted temperature effect- warm",
x = "Temperature deviation from 25C",
y = "Effect size",
color = "outcome",
fill = "outcome",
linetype = "outcome")
# Cool
preds.mlma.cool <- predict(mv_mlma_split.cool, addx=TRUE)
mlma_cool_data <- data_cool
mlma_cool_data$pred <- preds.mlma.cool$pred
mlma_cool_data$pred.lb <- preds.mlma.cool$pi.lb
mlma_cool_data$pred.ub <- preds.mlma.cool$pi.ub
mlma_cool_data$c.lb <- preds.mlma.cool$ci.lb
mlma_cool_data$c.ub <- preds.mlma.cool$ci.ub
ggplot(data = mlma_cool_data, aes(x = c_treattemp, y = pred, col = outcome, linetype = outcome)) +
geom_ribbon(aes(ymin = c.lb, ymax = c.ub, fill = outcome), alpha = 0.15) +
geom_line() +
scale_color_manual(values = c("purple", "orange")) +
scale_fill_manual(values = c("purple", "orange")) +
scale_linetype_manual(values = c("solid", "dashed")) +
theme_bw() +
labs(title = "Predicted temperature effect- cool",
x = "Temperature deviation from 25C",
y = "Effect size",
color = "outcome",
fill = "outcome",
linetype = "outcome")
data_warm <- subset(data_long_final, warm.cool == "Warm")
data_cool <- subset(data_long_final, warm.cool == "Cool")
# Warm
preds.mlma.warm <- predict(mv_mlma_split.warm_quad, addx=TRUE)
mlma_warm_data <- data_warm
mlma_warm_data$pred <- preds.mlma.warm$pred
mlma_warm_data$pred.lb <- preds.mlma.warm$pi.lb
mlma_warm_data$pred.ub <- preds.mlma.warm$pi.ub
mlma_warm_data$c.lb <- preds.mlma.warm$ci.lb
mlma_warm_data$c.ub <- preds.mlma.warm$ci.ub
ggplot(data = mlma_warm_data, aes(x = c_treattemp, y = pred, col = outcome, linetype = outcome)) +
geom_ribbon(aes(ymin = c.lb, ymax = c.ub, fill = outcome), alpha = 0.15) +
geom_line() +
scale_color_manual(values = c("purple", "orange")) +
scale_fill_manual(values = c("purple", "orange")) +
scale_linetype_manual(values = c("solid", "dashed")) +
theme_bw() +
labs(title = "Predicted temperature effect- warm",
x = "Temperature deviation from 25C",
y = "Effect size",
color = "outcome",
fill = "outcome",
linetype = "outcome")
# Cool
preds.mlma.cool <- predict(mv_mlma_split.cool_quad, addx=TRUE)
mlma_cool_data <- data_cool
mlma_cool_data$pred <- preds.mlma.cool$pred
mlma_cool_data$pred.lb <- preds.mlma.cool$pi.lb
mlma_cool_data$pred.ub <- preds.mlma.cool$pi.ub
mlma_cool_data$c.lb <- preds.mlma.cool$ci.lb
mlma_cool_data$c.ub <- preds.mlma.cool$ci.ub
ggplot(data = mlma_cool_data, aes(x = c_treattemp, y = pred, col = outcome, linetype = outcome)) +
geom_ribbon(aes(ymin = c.lb, ymax = c.ub, fill = outcome), alpha = 0.15) +
geom_line() +
scale_color_manual(values = c("purple", "orange")) +
scale_fill_manual(values = c("purple", "orange")) +
scale_linetype_manual(values = c("solid", "dashed")) +
theme_bw() +
labs(title = "Predicted temperature effect- cool",
x = "Temperature deviation from 25C",
y = "Effect size",
color = "outcome",
fill = "outcome",
linetype = "outcome")
data_warm <- subset(data_long_final, warm.cool == "Warm")
data_cool <- subset(data_long_final, warm.cool == "Cool")
## make V matrix for warm
V_warm <- make_VCV_matrix(data = data_warm, cluster = "trial",  V = "v", rho = 0.5)
V2_warm <- metaAidR::make_VCV_matrix(data = data_warm, matrix = V_warm, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_warm) # FALSE
V2_warm <- Matrix::nearPD(V2_warm)$mat
corpcor::is.positive.definite(V2_warm) # TRUE
## make V matrix for cool
V_cool <- make_VCV_matrix(data = data_cool, cluster = "trial",  V = "v", rho = 0.5)
V2_cool <- metaAidR::make_VCV_matrix(data = data_cool, matrix = V_cool, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_cool) # FALSE
V2_cool <- Matrix::nearPD(V2_cool)$mat
corpcor::is.positive.definite(V2_cool) # TRUE
mv_mlma_split.warm <- rma.mv(es ~ outcome*c_treattemp, V = V_warm,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_warm, test = "t", dfs = "contain")
mv_mlma_split.warm <- rma.mv(es ~ outcome*c_treattemp, V = V2_warm,    # This should compare whether the linear effect of temperature differs between the two outcomes when we allow for intercept, but without intercept  it will test whether there is a linear effect of temperature on each outcome separately and estimate that effect
random = list(~outcome - 1 | trial,        # This would be equivalent to an obs level random effect bc trial is unique to each two effects
~outcome - 1 | Paper.code),  # This should estimate a study level random effect for each outcome.
struc = "UN", data = data_warm, test = "t", dfs = "contain")
saveRDS(mv_mlma_split.warm, here("output", "models", "mv_mlma_split.warm.rds"))
cis_phi_warm <- confint(mv_mlma_split.warm, phi = 1)
cis_phi_warm
cis_rho_warm <- confint(mv_mlma_split.warm, rho = 1)
cis_warm <- rbind(cis_phi_warm, cis_rho_warm)
cis_warm
cis_rho_warm
rbind(cis_rho_warm, cis_phi_warm)
cbind(cis_rho_warm, cis_phi_warm)
class(cis_rho_warm)
as.vector(cis_rho_warm)
rbind(as.vector(cis_rho_warm), as.vector(cis_phi_warm))
as.data.frame(cis_rho_warm)
test <- as.data.frame(cis_rho_warm)
View(test)
test2 <- as.data.frame(cis_phi_warm)
View(test2)
rbind(test, test2)
View(cis_warm)
test <- as.data.frame(cis_phi_warm)
test2 <- as.data.frame(cis_rho_warm)
cis_warm <- rbind(test, test2)
View(cis_warm)
write.csv(cis_warm, here("output", "tables", "mv_mlma_split
write.csv(cis_warm, here("output", "tables", "mv_mlma_split.warm_cis.csv"))
cis_warm <- read.csv(here("output", "tables", "mv_mlma_split.wamr_cis.csv"))
cis_warm <- read.csv(here("output", "tables", "mv_mlma_split.warm_cis.csv"))
View(cis_warm)
rerun
rerun=TRUE
if(rerun){
data_warm <- subset(data_long_final, warm.cool == "Warm")
data_cool <- subset(data_long_final, warm.cool == "Cool")
## make V matrix for warm
V_warm <- make_VCV_matrix(data = data_warm, cluster = "trial",  V = "v", rho = 0.5)
V2_warm <- metaAidR::make_VCV_matrix(data = data_warm, matrix = V_warm, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_warm) # FALSE
V2_warm <- Matrix::nearPD(V2_warm)$mat
corpcor::is.positive.definite(V2_warm) # TRUE
## make V matrix for cool
V_cool <- make_VCV_matrix(data = data_cool, cluster = "trial",  V = "v", rho = 0.5)
V2_cool <- metaAidR::make_VCV_matrix(data = data_cool, matrix = V_cool, cluster = "shared_control",  V = "v", rho = 0.5)
corpcor::is.positive.definite(V2_cool) # FALSE
V2_cool <- Matrix::nearPD(V2_cool)$mat
corpcor::is.positive.definite(V2_cool) # TRUE
### Linear models
mv_mlma_split.warm <- rma.mv(es ~ outcome*c_treattemp, V = V2_warm,
random = list(~outcome - 1 | trial, ~outcome - 1 | Paper.code),
struc = "UN", data = data_warm, test = "t", dfs = "contain")
mv_mlma_split.cool <- rma.mv(es ~ outcome*c_treattemp, V = V2_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
cis_phi_warm <- as.data.frame(confint(mv_mlma_split.warm, phi = 1))
cis_rho_warm <- as.data.frame(confint(mv_mlma_split.warm, rho = 1))
cis_warm <- rbind(cis_phi_warm, cis_rho_warm)
cis_phi_cool <- as.data.frame(confint(mv_mlma_split.cool, phi = 1))
cis_rho_cool <- as.data.frame(confint(mv_mlma_split.cool, rho = 1))
cis_cool <- rbind(cis_phi_cool, cis_rho_cool)
write.csv(cis_cool, here("output", "tables", "mv_mlma_split.cool_cis.csv"))
write.csv(cis_warm, here("output", "tables", "mv_mlma_split.warm_cis.csv"))
### Quadratic models
mv_mlma_split.warm_quad <- rma.mv(es ~ outcome*poly(c_treattemp, degree=2, raw=TRUE), V = V2_warm,
random = list(~outcome - 1 | trial, ~outcome - 1 | Paper.code),
struc = "UN", data = data_warm, test = "t", dfs = "contain")
mv_mlma_split.cool_quad <- rma.mv(es ~ outcome*poly(c_treattemp, degree=2, raw=TRUE), V = V2_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
cis_phi_warm.q <- as.data.frame(confint(mv_mlma_split.warm_quad, phi = 1))
cis_rho_warm.q <- as.data.frame(confint(mv_mlma_split.warm_quad, rho = 1))
cis_warm.q <- rbind(cis_phi_warm.q, cis_rho_warm.q)
cis_phi_cool.q <- as.data.frame(confint(mv_mlma_split.cool_quad, phi = 1))
cis_rho_cool.q <- as.data.frame(confint(mv_mlma_split.cool_quad, rho = 1))
cis_cool.q <- rbind(cis_phi_cool.q, cis_rho_cool.q)
write.csv(cis_cool.q, here("output", "tables", "mv_mlma_split.cool_cis_quad.csv"))
write.csv(cis_warm.q, here("output", "tables", "mv_mlma_split.warm_cis-quad.csv"))
### Cubic models
mv_mlma_split.warm_cubic <- rma.mv(es ~ outcome*poly(c_treattemp, degree=3, raw=TRUE), V = V2_warm,
random = list(~outcome - 1 | trial, ~outcome - 1 | Paper.code),
struc = "UN", data = data_warm, test = "t", dfs = "contain")
mv_mlma_split.cool_cubic <- rma.mv(es ~ outcome*poly(c_treattemp, degree=3, raw=TRUE), V = V2_cool,
random = list(~outcome - 1 | trial,  ~outcome - 1 | Paper.code),
struc = "UN", data = data_cool, test = "t", dfs = "contain")
cis_phi_warm.c <- as.data.frame(confint(mv_mlma_split.warm_cubic, phi = 1))
cis_rho_warm.c <- as.data.frame(confint(mv_mlma_split.warm_cubic, rho = 1))
cis_warm.c <- rbind(cis_phi_warm.c, cis_rho_warm.c)
cis_phi_cool.c <- as.data.frame(confint(mv_mlma_split.cool_cubic, phi = 1))
cis_rho_cool.c <- as.data.frame(confint(mv_mlma_split.cool_cubic, rho = 1))
cis_cool.c <- rbind(cis_phi_cool.c, cis_rho_cool.c)
write.csv(cis_cool.c, here("output", "tables", "mv_mlma_split.cool_cis_cubic.csv"))
write.csv(cis_warm.c, here("output", "tables", "mv_mlma_split.warm_cis-cubic.csv"))
saveRDS(mv_mlma_split.warm, here("output", "models", "mv_mlma_split.warm.rds"))
saveRDS(mv_mlma_split.cool, here("output", "models", "mv_mlma_split.cool.rds"))
saveRDS(mv_mlma_split.warm_quad, here("output", "models", "mv_mlma_split.warm_quad.rds"))
saveRDS(mv_mlma_split.cool_quad, here("output", "models", "mv_mlma_split.cool_quad.rds"))
saveRDS(mv_mlma_split.warm_cubic, here("output", "models", "mv_mlma_split.warm_cubic.rds"))
saveRDS(mv_mlma_split.cool_cubic, here("output", "models", "mv_mlma_split.cool_cubic.rds"))
} else {
#read in models
mv_mlma_split.warm <- readRDS(here("output", "models", "mv_mlma_split.warm.rds"))
mv_mlma_split.cool <- readRDS(here("output", "models", "mv_mlma_split.cool.rds"))
mv_mlma_split.warm_quad <- readRDS(here("output", "models", "mv_mlma_split.warm_quad.rds"))
mv_mlma_split.cool_quad <- readRDS(here("output", "models", "mv_mlma_split.cool_quad.rds"))
mv_mlma_split.warm_cubic <- readRDS(here("output", "models", "mv_mlma_split.warm_cubic.rds"))
mv_mlma_split.cool_cubic <- readRDS(here("output", "models", "mv_mlma_split.cool_cubic.rds"))
# read confidence intervals
cis_warm <- read.csv(here("output", "tables", "mv_mlma_split.warm_cis.csv"))
cis_cool <- read.csv(here("output", "tables", "mv_mlma_split.cool_cis.csv"))
cis_warm.q <- read.csv(here("output", "tables", "mv_mlma_split.warm_cis_quad.csv"))
cis_cool.q <- read.csv(here("output", "tables", "mv_mlma_split.cool_cis_quad.csv"))
cis_warm.c <- read.csv(here("output", "tables", "mv_mlma_split.warm_cis_cubic.csv"))
cis_cool.c <- read.csv(here("output", "tables", "mv_mlma_split.cool_cis_cubic.csv"))
}
